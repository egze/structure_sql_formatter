defmodule StructureSqlFormatterTest do
  use ExUnit.Case, async: true
  doctest StructureSqlFormatter

  describe "remove_trailing_whitespace" do
    setup do
      sql = File.read!(__DIR__ <> "/fixtures/remove_trailing_whitespace.sql")

      %{sql: sql}
    end

    test "removes trailing whitespace", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        -- Do not edit this file in editor, it will remove trailing whitespace
        SET client_encoding = 'UTF8';
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_trailing_whitespace: false]
        )

      # not multi line, because I don't know how to make the editor prevent removing trailing whitespace
      assert "-- Do not edit this file in editor, it will remove trailing whitespace  \nSET client_encoding = 'UTF8';\t\n" ==
               formatted_sql
    end
  end

  describe "remove_version_specific_output" do
    setup do
      sql =
        ~s"""
        -- PostgreSQL database dump

        -- Dumped from database version 14.5
        -- Dumped by pg_dump version 15.3

        SET lock_timeout = 0;
        SET row_security = off;
        SET idle_in_transaction_session_timeout = 0;
        SET default_with_oids = false;
        SET xmloption = content;
        SET default_table_access_method = heap;
        """

      %{sql: sql}
    end

    test "removes version specific output", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        -- PostgreSQL database dump

        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_version_specific_output: false]
        )

      expected_sql =
        ~s"""
        -- PostgreSQL database dump

        -- Dumped from database version 14.5
        -- Dumped by pg_dump version 15.3

        SET lock_timeout = 0;
        SET row_security = off;
        SET idle_in_transaction_session_timeout = 0;
        SET default_with_oids = false;
        SET xmloption = content;
        SET default_table_access_method = heap;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_useless_comment_lines" do
    setup do
      sql =
        ~s"""
        --
        -- PostgreSQL database dump
        --

        SET lock_timeout = 0;
        """

      %{sql: sql}
    end

    test "removes useless comment lines", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        -- PostgreSQL database dump

        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_useless_comment_lines: false]
        )

      expected_sql =
        ~s"""
        --
        -- PostgreSQL database dump
        --

        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_pg_stat_statements_extension" do
    setup do
      sql =
        ~s"""
        SET lock_timeout = 0;

        -- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: -

        CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA public;
        """

      %{sql: sql}
    end

    test "removes pg_stat_statements extension", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_pg_stat_statements_extension: false]
        )

      expected_sql =
        ~s"""
        SET lock_timeout = 0;

        -- Name: pg_stat_statements; Type: EXTENSION

        CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA public;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_pg_buffercache_extension" do
    setup do
      sql =
        ~s"""
        SET lock_timeout = 0;

        -- Name: pg_buffercache; Type: EXTENSION; Schema: -; Owner: -

        CREATE EXTENSION IF NOT EXISTS pg_buffercache WITH SCHEMA public;
        """

      %{sql: sql}
    end

    test "removes pg_buffercache extension", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_pg_buffercache_extension: false]
        )

      expected_sql =
        ~s"""
        SET lock_timeout = 0;

        -- Name: pg_buffercache; Type: EXTENSION

        CREATE EXTENSION IF NOT EXISTS pg_buffercache WITH SCHEMA public;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_comments_on_extensions" do
    setup do
      sql =
        ~s"""
        SET lock_timeout = 0;

        -- Name: EXTENSION btree_gist; Type: COMMENT; Schema: -; Owner: -

        COMMENT ON EXTENSION btree_gist IS 'support for indexing common datatypes in GiST';
        """

      %{sql: sql}
    end

    test "removes comment on extension", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_comments_on_extensions: false]
        )

      expected_sql =
        ~s"""
        SET lock_timeout = 0;

        -- Name: EXTENSION btree_gist; Type: COMMENT

        COMMENT ON EXTENSION btree_gist IS 'support for indexing common datatypes in GiST';
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_useless_version_specific_parts_of_comments" do
    setup do
      sql =
        ~s"""
        -- Name: whatever; Type: EXTENSION; Schema: -; Owner: -

        CREATE EXTENSION IF NOT EXISTS whatever WITH SCHEMA public;

        -- Name: whatever; Type: EXTENSION; Schema: -; Owner: -

        CREATE EXTENSION IF NOT EXISTS whatever WITH SCHEMA public;
        """

      %{sql: sql}
    end

    test "removes useless version specific parts of comments", %{sql: sql} do
      formatted_sql = StructureSqlFormatter.format(sql)

      expected_sql =
        ~s"""
        -- Name: whatever; Type: EXTENSION

        CREATE EXTENSION IF NOT EXISTS whatever WITH SCHEMA public;

        -- Name: whatever; Type: EXTENSION

        CREATE EXTENSION IF NOT EXISTS whatever WITH SCHEMA public;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_useless_version_specific_parts_of_comments: false]
        )

      expected_sql =
        ~s"""
        -- Name: whatever; Type: EXTENSION; Schema: -; Owner: -

        CREATE EXTENSION IF NOT EXISTS whatever WITH SCHEMA public;

        -- Name: whatever; Type: EXTENSION; Schema: -; Owner: -

        CREATE EXTENSION IF NOT EXISTS whatever WITH SCHEMA public;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "reduce_noise_for_id_fields" do
    setup do
      sql =
        ~s"""
        CREATE TABLE public.some_table (
            id integer NOT NULL,
            id bigint NOT NULL,
            id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
            id uuid DEFAULT gen_random_uuid() NOT NULL,
        );

        CREATE SEQUENCE public.some_table_id_seq
            START WITH 1
            INCREMENT BY 1
            NO MINVALUE
            NO MAXVALUE
            CACHE 1;

        --
        -- Name: some_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
        --

        ALTER SEQUENCE public.some_table_id_seq OWNED BY public.some_table.id;

        --
        -- Name: some_table id; Type: DEFAULT; Schema: public; Owner: -
        --

        ALTER TABLE ONLY public.some_table ALTER COLUMN id SET DEFAULT nextval('public.some_table_id_seq'::regclass);

        --
        -- Name: some_table some_table_pkey; Type: CONSTRAINT; Schema: public; Owner: -
        --

        ALTER TABLE ONLY public.some_table
            ADD CONSTRAINT some_table_pkey PRIMARY KEY (id);
        """

      %{sql: sql}
    end

    test "reduces noise for id fields", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [reduce_noise_for_id_fields: true]
        )

      expected_sql =
        ~s"""
        CREATE TABLE public.some_table (
            id SERIAL PRIMARY KEY,
            id BIGSERIAL PRIMARY KEY,
            id uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
            id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
        );
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [reduce_noise_for_id_fields: false]
        )

      expected_sql =
        ~s"""
        CREATE TABLE public.some_table (
            id integer NOT NULL,
            id bigint NOT NULL,
            id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
            id uuid DEFAULT gen_random_uuid() NOT NULL,
        );

        CREATE SEQUENCE public.some_table_id_seq
            START WITH 1
            INCREMENT BY 1
            NO MINVALUE
            NO MAXVALUE
            CACHE 1;

        -- Name: some_table_id_seq; Type: SEQUENCE OWNED BY

        ALTER SEQUENCE public.some_table_id_seq OWNED BY public.some_table.id;

        -- Name: some_table id; Type: DEFAULT

        ALTER TABLE ONLY public.some_table ALTER COLUMN id SET DEFAULT nextval('public.some_table_id_seq'::regclass);

        -- Name: some_table some_table_pkey; Type: CONSTRAINT

        ALTER TABLE ONLY public.some_table
            ADD CONSTRAINT some_table_pkey PRIMARY KEY (id);
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_inherited_tables" do
    setup do
      sql =
        ~s"""
        -- Name: new_table; Type: TABLE


        CREATE TABLE public.new_table (
            state character(2)
        )
        INHERITS (public.some_table);

        -- Name: new_table id; Type: DEFAULT

        ALTER TABLE ONLY public.new_table ALTER COLUMN id SET DEFAULT nextval('public.accounts_id_seq'::regclass);

        -- Name: new_table_state_idx; Type: INDEX

        CREATE INDEX new_table_state_idx ON public.new_table USING btree (state);

        SET lock_timeout = 0;
        """

      %{sql: sql}
    end

    test "removes inherited tables", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_inherited_tables: true]
        )

      expected_sql =
        ~s"""
        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_inherited_tables: false]
        )

      expected_sql =
        ~s"""
        -- Name: new_table; Type: TABLE

        CREATE TABLE public.new_table (
            state character(2)
        )
        INHERITS (public.some_table);

        -- Name: new_table id; Type: DEFAULT

        ALTER TABLE ONLY public.new_table ALTER COLUMN id SET DEFAULT nextval('public.accounts_id_seq'::regclass);

        -- Name: new_table_state_idx; Type: INDEX

        CREATE INDEX new_table_state_idx ON public.new_table USING btree (state);

        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "remove_partitioned_tables" do
    setup do
      sql =
        ~s"""
        -- Name: table_partitioned_state_index; Type: INDEX ATTACH

        -- Name: table_partitioned_state_index; Type: INDEX

        CREATE INDEX table_partitioned_state_index ON public.table_partitioned_202201 USING btree (state);

        -- Name: table_partitioned_202201_pkey; Type: INDEX ATTACH

        ALTER INDEX public.table_partitioned_pkey ATTACH PARTITION public.table_partitioned_202201_pkey;

        -- Name: table_partitioned_202201_pkey; Type: TABLE ATTACH

        ALTER TABLE ONLY public.table_partitioned ATTACH PARTITION public.table_partitioned_202201 FOR VALUES FROM ('0332100300d32603033038306673330d3063060323030d034230d030330000323303033') TO ('0333630000d6363338024323330033330006331d003402d73d003303300003603030302');

        -- Name: table_partitioned table_partitioned_ref_id_fkey; Type: FK CONSTRAINT

        ALTER TABLE public.table_partitioned
            ADD CONSTRAINT table_partitioned_ref_id_fkey FOREIGN KEY (ref_id) REFERENCES public.users(id);

        -- Name: table_partitioned table_partitioned_pkey; Type: CONSTRAINT

        ALTER TABLE ONLY public.table_partitioned
            ADD CONSTRAINT table_partitioned_pkey PRIMARY KEY (id);

        -- Name: measurement_y2006m02; Type: TABLE

        CREATE TABLE public.measurement_y2006m02 PARTITION OF public.measurement
            FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

        SET lock_timeout = 0;
        """

      %{sql: sql}
    end

    test "removes separate ATTACH PARTITION statements in postgres 10" do
      sql =
        File.read!(__DIR__ <> "/fixtures/remove_inherited_tables/partitioning_postgres_10.sql")

      expected_sql =
        File.read!(
          __DIR__ <> "/fixtures/remove_inherited_tables/partitioning_postgres_10_expected.sql"
        )

      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_partitioned_tables: true]
        )

      assert expected_sql == formatted_sql
    end

    test "removes separate ATTACH PARTITION statements in postgres 12" do
      sql =
        File.read!(__DIR__ <> "/fixtures/remove_inherited_tables/partitioning_postgres_12.sql")

      expected_sql =
        File.read!(
          __DIR__ <> "/fixtures/remove_inherited_tables/partitioning_postgres_12_expected.sql"
        )

      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_partitioned_tables: true]
        )

      assert expected_sql == formatted_sql
    end

    test "removes separate ATTACH PARTITION statements in postgres 16" do
      sql =
        File.read!(__DIR__ <> "/fixtures/remove_inherited_tables/partitioning_postgres_16.sql")

      expected_sql =
        File.read!(
          __DIR__ <> "/fixtures/remove_inherited_tables/partitioning_postgres_16_expected.sql"
        )

      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_partitioned_tables: true]
        )

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [remove_partitioned_tables: false]
        )

      expected_sql =
        ~s"""
        -- Name: table_partitioned_state_index; Type: INDEX ATTACH

        -- Name: table_partitioned_state_index; Type: INDEX

        CREATE INDEX table_partitioned_state_index ON public.table_partitioned_202201 USING btree (state);

        -- Name: table_partitioned_202201_pkey; Type: INDEX ATTACH

        ALTER INDEX public.table_partitioned_pkey ATTACH PARTITION public.table_partitioned_202201_pkey;

        -- Name: table_partitioned_202201_pkey; Type: TABLE ATTACH

        ALTER TABLE ONLY public.table_partitioned ATTACH PARTITION public.table_partitioned_202201 FOR VALUES FROM ('0332100300d32603033038306673330d3063060323030d034230d030330000323303033') TO ('0333630000d6363338024323330033330006331d003402d73d003303300003603030302');

        -- Name: table_partitioned table_partitioned_ref_id_fkey; Type: FK CONSTRAINT

        ALTER TABLE public.table_partitioned
            ADD CONSTRAINT table_partitioned_ref_id_fkey FOREIGN KEY (ref_id) REFERENCES public.users(id);

        -- Name: table_partitioned table_partitioned_pkey; Type: CONSTRAINT

        ALTER TABLE ONLY public.table_partitioned
            ADD CONSTRAINT table_partitioned_pkey PRIMARY KEY (id);

        -- Name: measurement_y2006m02; Type: TABLE

        CREATE TABLE public.measurement_y2006m02 PARTITION OF public.measurement
            FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

        SET lock_timeout = 0;
        """

      assert expected_sql == formatted_sql
    end
  end

  describe "order_schema_migrations_values" do
    setup do
      sql =
        ~s"""
        SET lock_timeout = 0;

        -- PostgreSQL database dump complete

        INSERT INTO public."schema_migrations" (version) VALUES (20181001154335);
        INSERT INTO public."schema_migrations" (version) VALUES (20220303);
        INSERT INTO public."schema_migrations" (version) VALUES (20181004101931);
        INSERT INTO public."schema_migrations" (version) VALUES (20181004101443);
        INSERT INTO public."schema_migrations" (version) VALUES (2023022123817);
        INSERT INTO public."schema_migrations" (version) VALUES (20181004125817);
        """

      %{sql: sql}
    end

    test "orders schema migrations values", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [order_schema_migrations_values: true]
        )

      expected_sql =
        ~s"""
        SET lock_timeout = 0;

        -- PostgreSQL database dump complete

        INSERT INTO public."schema_migrations" (version) VALUES
         (20181001154335)
        ,(20181004101443)
        ,(20181004101931)
        ,(20181004125817)
        ,(20220303)
        ,(2023022123817)
        ;
        """

      assert expected_sql == formatted_sql
    end

    test "can be skipped", %{sql: sql} do
      formatted_sql =
        StructureSqlFormatter.format(sql,
          structure_sql_formatter_opts: [order_schema_migrations_values: false]
        )

      expected_sql =
        ~s"""
        SET lock_timeout = 0;

        -- PostgreSQL database dump complete

        INSERT INTO public."schema_migrations" (version) VALUES (20181001154335);
        INSERT INTO public."schema_migrations" (version) VALUES (20220303);
        INSERT INTO public."schema_migrations" (version) VALUES (20181004101931);
        INSERT INTO public."schema_migrations" (version) VALUES (20181004101443);
        INSERT INTO public."schema_migrations" (version) VALUES (2023022123817);
        INSERT INTO public."schema_migrations" (version) VALUES (20181004125817);
        """

      assert expected_sql == formatted_sql
    end
  end
end
